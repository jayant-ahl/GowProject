<!DOCTYPE html> 
<meta charset = "utf-8" > 

<style>

body {
	font: 10px sans-serif;
}

.chord path {
	fill-opacity: .67;
	stroke: #000;
  stroke-width: .5px;
}

</style>
<body>
<script src= "d3/d3.js" > 
</script>
	
<script>

// From http: //mkweb.bcgsc.ca/circos/guide/tables/
	var dataset = [];
	var matrix = [];
	d3.csv("Top/2001A.csv", function(data) {
		var totSum = 0;
		dataset = data;
		//console.log(dataset);
		var keys = Object.keys(dataset[0]);
		var cName = keys[0];
		var matrix = [];
		for (var i = 0; i < dataset.length; i++) {
			//console.log(dataset[i][keys[0]]);
			var cnImps = [];
			for (var j = 1; j < keys.length; j++) {
				var Val = +dataset[i][keys[j]];
				totSum += Val;
				cnImps.push(Val);
				
			}
			matrix.push(cnImps);
		}
		for (var i=0; i<matrix.length; i++){
			for (var j=0; j<matrix.length; j++){
				matrix[i][j] = 100*matrix[i][j]/totSum;
			}
		}
		//console.log(matrix);


		/*var matrix = [
			[11975, 5871, 8916, 2868, 2000],
			[1951, 10048, 2060, 6171, 3000],
			[8010, 16145, 8090, 8045, 1000],
			[1013, 990, 940, 6907, 4502],
			[3013, 2290, 1940, 1907, 5502]
		];*/

		var chord = d3.layout.chord()
			.padding(.05)
			.sortSubgroups(d3.descending)
			.matrix(matrix);

		var width = 1000,
			height = 1000,
			innerRadius = Math.min(width, height) * .30,
			outerRadius = innerRadius * 1.1;
		
		var colors = d3.scale.category20().range();
			colors.push("#637939");
		
		var fill = d3.scale.ordinal()
			.domain(d3.range(21))
			.range(colors);

		var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height)
			.append("g")
			.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
		
		var chords = svg.append("g")
			.attr("class", "chord")
			.selectAll("path")
			.data(chord.chords)
			.enter().append("path")
			.attr("d", d3.svg.chord().radius(innerRadius))
			.style("fill", function(d) {
				return fill(d.target.index);
			})
			.style("opacity", 1);
			
		chords.append("title").text(function(d){
				var line1 = "Transfers from " + keys[d["source"]["index"]+1] + " to " + keys[d["target"]["index"]+1] + " : " + Math.floor(d["target"]["value"]*totSum/100).toFixed(1).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
				var line2 = "Transfers from " + keys[d["target"]["index"]+1] + " to " + keys[d["source"]["index"]+1] + " : " + Math.floor(d["source"]["value"]*totSum/100).toFixed(1).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
				return line1 + "\n" + line2;
			});
		
			
		function fade_single(opacity) {
			  return function() {
			    var me = this;
			    svg.selectAll("g.chord path")
			        .filter(function(d) {
			          return this != me;
			        })
			      .transition()
			        .style("opacity", opacity);
			  };
			}
		
			
		chords.on("mouseover", fade_single(.1))
			.on("mouseout", fade_single(1));
		
		var paths = svg.append("g").selectAll("path")
			.data(chord.groups)
			.enter().append("path")
			.style("fill", function(d) {
				return fill(d.index);
			})
			.style("stroke", function(d) {
				return fill(d.index);
			})
			.attr("d", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius))
			.on("mouseover", fade(.1))
			.on("mouseout", fade(1));
			

			
		var ticks = svg.append("g").selectAll("g")
			.data(chord.groups)
			.enter().append("g").selectAll("g")
			.data(groupTicks)
			.enter().append("g")
			.attr("transform", function(d) {
				return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" + "translate(" + outerRadius + ",0)";
			});

		/*ticks.append("line")
			.attr("x1", 1)
			.attr("y1", 0)
			.attr("x2", 5)
			.attr("y2", 0)
			.style("stroke", "#000");*/

		/*ticks.append("text")
			.attr("x", 8)
			.attr("dy", ".35em")
			.attr("transform", function(d) {
				return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
			})
			.style("text-anchor", function(d) {
				return d.angle > Math.PI ? "end" : null;
			})
			.text(function(d) {
				return d.label;
			});*/

		
		
		svg.append("g").selectAll("path")
			.data(chord.groups)
			.enter().append("svg:text")
	        .each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
	        .attr("dy", ".35em")
	        .attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
	        .attr("transform", function(d) {
	          return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
	              + "translate(" + (innerRadius + 50) + ")"
	              + (d.angle > Math.PI ? "rotate(180)" : "");
	        })
	        .text(function(d) {return keys[d.index+1]; });

		// Returns an array of tick angles and labels, given a group.

		function groupTicks(d) {
			var k = (d.endAngle - d.startAngle) / d.value;
			return d3.range(0, d.value, 1000).map(function(v, i) {
				return {
					angle: v * k + d.startAngle,
					label: i % 5 ? null : v / 1000 + "k"
				};
			});
		}

		// Returns an event handler for fading a given chord group.

		function fade(opacity) {
			return function(g, i) {
				svg.selectAll(".chord path")
					.filter(function(d) {
						return d.source.index != i && d.target.index != i;
					})
					.transition()
					.style("opacity", opacity);
			};
		}
	}); 
</script>
